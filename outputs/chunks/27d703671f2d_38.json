{
  "content": "_doc_freq.get(term, 0) + 1)) + 1\n            \n            # TF-IDF score\n            vector[term] = tf * idf\n        \n        return vector\n    \n    def similarity(self, vec1, vec2):\n        \"\"\"Calculate cosine similarity between two vectors\"\"\"\n        # Find common terms\n        common_terms = set(vec1.keys()) & set(vec2.keys())\n        \n        # Calculate dot product\n        dot_product = sum(vec1[term] * vec2[term] for term in common_terms)\n        \n        # Calculate magnitudes\n        mag1 = math.sqrt(sum(val * val for val in vec1.values()))\n        mag2 = math.sqrt(sum(val * val for val in vec2.values()))\n        \n        # Calculate cosine similarity (avoid division by zero)\n        if mag1 * mag2 == 0:\n            return 0\n        return dot_product / (mag1 * mag2)\n\nclass SimpleVectorStore:\n    \"\"\"Simple vector store using the SimpleVectorizer\"\"\"\n    \n    def __init__(self, texts, metadata=None):\n        self.vectorizer = SimpleVectorizer()\n        self.texts = texts\n        self.metadata = metadata if metadata else [{}] * len(texts)\n        \n        # Process all texts\n        self.vectorizer.fit(texts)\n        self.vectors = [self.vectorizer.get_vector(text) for text in texts]\n        \n    def similarity_search(self, query, top_k=3):\n        \"\"\"Find the most similar documents to the query\"\"\"\n        if len(self.vectors) == 0:\n            return []\n        \n        # Get query vector\n        query_vector = self.vectorizer.get_vector(query)\n        \n        # Calculate similarities\n        similarities = [\n            self.vectorizer.similarity(query_vector, doc_vector)\n            for doc_vector in self.vectors\n        ]\n        \n        # Create results with index, text, metadata, and similarity\n        results_with_idx = [\n            (idx, self.texts[idx], self.metadata[idx], similarities[idx])\n            for idx in range(len(self.texts))\n        ]\n        \n        # Sort by similarity in descending order\n        results_with_idx.sort(key=lambda x: x[",
  "metadata": {
    "source": "/mnt/chromeos/removable/USB Drive/review_assistant/codebase/chat_sessions/Chat_with_CFO_20250521_113849.txt",
    "chunk_id": "27d703671f2d_38",
    "start_char": 68400,
    "end_char": 70400,
    "created_at": "2025-05-21T06:08:50+00:00"
  }
}